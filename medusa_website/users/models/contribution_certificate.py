from datetime import datetime
from typing import List, Literal, Optional

import markdown
from django.conf import settings
from django.contrib.auth.models import Group
from django.core.files.base import ContentFile
from django.core.handlers.wsgi import WSGIRequest
from django.core.mail import EmailMultiAlternatives
from django.db import models
from django.db.models import Count, QuerySet
from django.urls import reverse
from django.utils.safestring import mark_safe
from django_lifecycle import AFTER_UPDATE, BEFORE_UPDATE, LifecycleModel, hook
from martor.models import MartorField
from playwright.sync_api import sync_playwright

from medusa_website.users.models import Contribution, User
from medusa_website.utils.general import get_pretty_logger

logger = get_pretty_logger(__name__)


class ContributionCertificate(LifecycleModel):
    """
    Represents a certificate of contributions for a particular user.
    """

    user = models.ForeignKey(
        User,
        help_text="User the this contribution certificate corresponds to",
        on_delete=models.CASCADE,
        related_name="contribution_certificates",
    )
    date_modified = models.DateField(help_text="Date the certificate was generated", auto_now=True)
    signed_off_by = models.ForeignKey(
        User,
        help_text="User who signed off contribution, if required",
        on_delete=models.PROTECT,
        related_name="signed_contribution_certificates",
        null=True,
        blank=True,
    )
    signed_off_date = models.DateField(help_text="Date the contribution was signed off", null=True, blank=True)
    is_signed_off = models.BooleanField(help_text="True if the certificate is signed", default=False)
    details = MartorField(
        help_text="Markdown formatted details. This will be generated automatically by "
        "ContributionCertificate.gen_cert_detail_text, but can be set manually too.\n"
        "If this is modified, the certificate pdfs will need to be regenerated.",
    )
    autogenerated = models.BooleanField(help_text="If True, was autogenerated by the user", default=False)
    preview_pdf = models.FileField(upload_to="contribution_certificates/previews", null=True, blank=True)
    signed_pdf = models.FileField(upload_to="contribution_certificates/signed", null=True, blank=True)
    date_sent_for_signoff = models.DateField(
        help_text="Date the certificate was requested for signoff", null=True, blank=True
    )
    sent_for_signoff = models.BooleanField(help_text="True if sent for signoff", default=False)

    @staticmethod
    def sum_contribs(contribs: QuerySet[Contribution], filter_min_contribs=False):
        """
        Groups and aggregates contributions into subtypes, and then types of contribution

        Example return:
        {
            "WEBSITE" : {
                "MCQ_BANK_QUESTION_REVIEW": {"template": "Creating $COUNT MCQ Bank Questions", "count": 59}
            }
        }
        """
        # This method is a bit of a mess, worth stepping through manually to see whats going on if you're confused!
        count_dicts = list(
            contribs.values("type__machine_name", "type__subtype", "type__template").annotate(Count("id"))
        )
        out_dict = {}
        for d in count_dicts:
            if filter_min_contribs:
                # Get minimum number of contributions, below which won't count, e.g. OSCE_BANK_STATION_CREATE_MIN
                min_count = getattr(settings, d["type__machine_name"] + "_MIN")
                if d["id__count"] < min_count:
                    continue
            if not out_dict.get(d["type__subtype"]):
                out_dict[d["type__subtype"]] = {}
            out_dict[d["type__subtype"]][d["type__machine_name"]] = {
                "template": d["type__template"],
                "count": d["id__count"],
            }
        return out_dict

    @classmethod
    def gen_contributions_and_roles_dict(cls, user: User):
        return {
            "roles": user.committee_member_records.all(),
            "website": cls.sum_contribs(
                user.contributions.filter(type__subtype="WEBSITE"), filter_min_contribs=True
            ).get("WEBSITE"),
            "events": user.contributions.filter(type__subtype="EVENTS"),
            "other": user.contributions.filter(type__subtype="OTHER"),
        }

    @classmethod
    def generate_for_user(cls, user: User) -> "ContributionCertificate":
        logger.info(f"Generating contributions for user {user}")
        Contribution.gen_mcq_bank_contributions_for_user(user)
        Contribution.gen_osce_bank_contributions_for_user(user)

        cert_details = cls.gen_cert_detail_text(user=user)
        cert = cls(user=user, autogenerated=True, details=cert_details)
        cert.save()
        return cert

    @hook(AFTER_UPDATE, when="details", has_changed=True)
    def on_details_change(self):
        if self.preview_pdf:
            self.preview_pdf.delete()
        if self.signed_pdf:
            self.signed_pdf.delete()
            self.is_signed_off = False
            self.signed_off_by = None
            self.signed_off_date = None

    def gen_pdf(self, request: WSGIRequest, signed: bool):
        headers = dict(request.headers)
        if signed:
            assert self.is_signed_off is True, "Attempted to generate signed pdf but it is not signed off"
            cert_url = request.build_absolute_uri(reverse("users:certificate_detail_signed", kwargs={"id": self.id}))
        else:
            cert_url = request.build_absolute_uri(reverse("users:certificate_detail", kwargs={"id": self.id}))
        with sync_playwright() as p:
            browser = p.chromium.launch()
            page = browser.new_page()
            page.set_extra_http_headers({"Cookie": headers["Cookie"]})
            page.goto(cert_url)
            # https://playwright.dev/python/docs/api/class-page#page-pdf
            # Image size is 1754 x 1240
            pdf = page.pdf(prefer_css_page_size=True, print_background=True, width="1754px", height="1240px")
            browser.close()

        if signed:
            self.signed_pdf = ContentFile(content=pdf, name=f"{self.user.member_id}_certificate.pdf")
        else:
            self.preview_pdf = ContentFile(content=pdf, name=f"{self.user.member_id}_PREVIEW_certificate.pdf")
        self.save()

    def email_to_user(self):
        raise NotImplementedError()

    def pdfs_to_gen(self) -> List[str]:
        out = []
        if self.is_signed_off and not self.signed_pdf:
            out.append("signed_pdf")
        if not self.is_signed_off and not self.preview_pdf:
            out.append("preview_pdf")
        return out

    @staticmethod
    def cert_signers() -> List[User]:
        from medusa_website.org_chart.models import CommitteeRoleRecord

        current_year = datetime.today().year
        committee_members = [
            CommitteeRoleRecord.objects.get(role__email="president@medusa.org.au", year=current_year),
            CommitteeRoleRecord.objects.get(role__email="vp@medusa.org.au", year=current_year),
        ]
        signers = [mem.user for mem in committee_members]
        return signers

    @classmethod
    def gen_cert_detail_text(cls, user) -> str:
        contrib_and_roles = cls.gen_contributions_and_roles_dict(user=user)
        texts = []
        if contrib_and_roles["roles"]:
            extra = "MeDUSA Committee Roles:\n\n"
            for role_record in contrib_and_roles["roles"]:
                extra += f"* {role_record.role.position} ({role_record.year})\n"
            texts.append(extra)

        if contrib_and_roles.get("website"):
            extra = "Contributing to the MeDUSA Website:\n\n"
            for contrib in contrib_and_roles["website"].values():
                extra += f"* {contrib['template'].replace('$COUNT', str(contrib['count']))}\n"
            texts.append(extra)

        if contrib_and_roles.get("events"):
            extra = "Contributing to MeDUSA Events:\n\n"
            for contrib in contrib_and_roles["events"].values():
                extra += f"* {contrib.description} - {contrib.date}\n"
            texts.append(extra)

        if contrib_and_roles.get("other"):
            if len(texts) == 0:
                extra = "Contributions:\n"
            else:
                extra = "Other contributions:\n"
            for contrib in contrib_and_roles["other"].values():
                extra += f"* {contrib.description} - {contrib.date}\n"
            texts.append(extra)

        return "\n".join(texts)

    def details_as_html(self):
        if self.details:
            html = markdown.markdown(self.details)
            return mark_safe(html)
        else:
            return mark_safe("<i>No details provided!</i>")

    def sign_with_user(self, request: WSGIRequest, signing_user: User, email_user: True):
        assert signing_user.has_contrib_sign_off_permission()
        self.signed_off_by = signing_user
        self.signed_off_date = datetime.today().date()
        self.is_signed_off = True
        self.save()

        if email_user:
            url_to_signed_pdf = request.build_absolute_uri(
                reverse("users:certificate_pdf_signed", kwargs={"id": self.id})
            )
            cert_user = self.user
            subject = f"Contribution Certificate has been signed off"
            message = (
                f"Dear {cert_user.name}, \n"
                f"Your contribution certificate has been signed by {signing_user.name} ({signing_user.email}).\n\n"
                f"You can view the signed certificate here: {url_to_signed_pdf}\n\n"
                f"Kind regards,\n\n The MeDUSA team"
            )
            recipients = [self.user.email]
            msg = EmailMultiAlternatives(
                subject=subject,
                body=message,
                from_email=settings.DEFAULT_FROM_EMAIL,
                to=recipients,
                cc=[signing_user.email],
                reply_to=[signing_user.email],
            )
            if not settings.DEBUG:
                msg.send()
            else:
                logger.warning(f"DID NOT SEND MESSAGE AS DEBUG MODE IS ACTIVE. Message below\n: \n{message}")

    def send_signoff_request(self, request: WSGIRequest):
        if self.is_signed_off or self.sent_for_signoff:
            return None
        contrib_sign_off_group_users = Group.objects.get(name="Contributions Sign Off").user_set.all()
        url_to_preview_pdf = request.build_absolute_uri(reverse("users:certificate_pdf", kwargs={"id": self.id}))
        url_to_cert_signoff_list = request.build_absolute_uri(
            reverse("admin:users_contributioncertificate_changelist") + "?is_signed_off__exact=0"
        )
        requesting_user: User = request.user
        subject = f"[INTERNAL] Contribution Certificate request from {requesting_user.name} - {requesting_user.email}"
        message = (
            f"Hi there, \n"
            f"{requesting_user.name} (member id {requesting_user.member_id}) has requested one of us to sign "
            f"off on their Contribution Certificate.\n\n"
            f"You can view the un-signed preview here: {url_to_preview_pdf}\n\n"
            f"You can view all pending Contribution Certificate Requests here: {url_to_cert_signoff_list}\n\n"
            f"You do not need to notify the user or reply to this email, they will receive an email when the signoff completes."
        )
        recipients = [u.email for u in contrib_sign_off_group_users]
        msg = EmailMultiAlternatives(
            subject=subject,
            body=message,
            from_email=settings.DEFAULT_FROM_EMAIL,
            to=recipients,
            cc=[request.user.email],
            reply_to=[request.user.email],
        )
        if not settings.DEBUG:
            msg.send()
        else:
            logger.warning(f"DID NOT SEND MESSAGE AS DEBUG MODE IS ACTIVE. Message below\n: \n{message}")
        self.sent_for_signoff = True
        self.date_sent_for_signoff = datetime.today().date()
        self.save()
